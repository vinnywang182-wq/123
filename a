原始版本
import pandas as pd
import json

def flatten_nested_columns(df):
    """
    Flattens only the nested (dict/list/JSON) columns of a DataFrame.
    Column names of flattened parts are renamed with dot notation.
    Non-nested columns are left unchanged.

    Args:
        df (pd.DataFrame): Input DataFrame

    Returns:
        pd.DataFrame: DataFrame with only nested fields flattened
    """

    def parse_json(val):
        # Try to parse JSON strings into Python objects (dict or list)
        if isinstance(val, str):
            try:
                return json.loads(val)
            except json.JSONDecodeError:
                return val
        return val

    def flatten_element(elem, prefix=''):
        # Recursively flatten dicts and lists into a flat dict with dot-separated keys
        items = {}
        if isinstance(elem, dict):
            for k, v in elem.items():
                new_key = f"{prefix}.{k}" if prefix else k
                items.update(flatten_element(v, new_key))
        elif isinstance(elem, list):
            for i, v in enumerate(elem):
                new_key = f"{prefix}.{i}" if prefix else str(i)
                items.update(flatten_element(v, new_key))
        else:
            items[prefix] = elem
        return items

    df = df.copy()
    for col in df.columns:
        if df[col].dtype == 'object':
            # Try to parse as JSON if it's a string
            df[col] = df[col].apply(parse_json)

    flat_cols = []
    for col in df.columns:
        if df[col].apply(lambda x: isinstance(x, (dict, list))).any():
            # Needs flattening
            flat_dicts = df[col].apply(lambda x: flatten_element(x, col) if isinstance(x, (dict, list)) else {col: x})
            flat_df = pd.DataFrame(flat_dicts.tolist())
            flat_cols.append(flat_df)
        else:
            # No flattening needed
            flat_cols.append(df[[col]])

    return pd.concat(flat_cols, axis=1)






















error版本
import pandas as pd
import json
import numpy as np

def flatten_dict(d, parent_key='', sep='.'):
    """递归展开嵌套字典或列表"""
    items = {}
    if isinstance(d, dict):
        if not d:
            items[parent_key] = {}
        else:
            for k, v in d.items():
                new_key = f"{parent_key}{sep}{k}" if parent_key else k
                items.update(flatten_dict(v, new_key, sep=sep))
    elif isinstance(d, list):
        if not d:
            items[parent_key] = []
        else:
            for i, v in enumerate(d):
                new_key = f"{parent_key}{sep}{i}" if parent_key else str(i)
                items.update(flatten_dict(v, new_key, sep=sep))
    else:
        items[parent_key] = d
    return items

def try_parse_json(val):
    if isinstance(val, str):
        try:
            parsed = json.loads(val)
            if isinstance(parsed, (dict, list)):
                return parsed
        except Exception:
            return val
    return val

def flatten_row(row):
    """一次性处理整行，返回平铺后的字典"""
    flat = {}
    for col, val in row.items():
        parsed_val = try_parse_json(val)
        if isinstance(parsed_val, (dict, list)):
            nested = flatten_dict(parsed_val, col)
            flat.update(nested)
        else:
            flat[col] = parsed_val
    return flat

def flatten_dataframe(df):
    """高性能扁平化函数"""
    flat_data = df.apply(flatten_row, axis=1, result_type='expand')
    # 替换空结构为 NaN（可选）
    flat_data = flat_data.replace({(): np.nan, []: np.nan, {}: np.nan})
    return flat_data







更新版本
import pandas as pd
import json

def flatten_nested_columns_with_empty(df):
    """
    Flattens nested (dict/list/JSON) columns of a DataFrame, preserving empty dicts and lists.
    Column names of flattened parts are renamed using dot notation.
    Non-nested columns are left unchanged.

    Args:
        df (pd.DataFrame): Input DataFrame

    Returns:
        pd.DataFrame: Flattened DataFrame with empty structures preserved
    """

    def parse_json(val):
        # Try to parse JSON strings into Python objects (dict or list)
        if isinstance(val, str):
            try:
                return json.loads(val)
            except json.JSONDecodeError:
                return val
        return val

    def flatten_element(elem, prefix=''):
        # Recursively flatten dicts and lists into a flat dict with dot-separated keys
        items = {}
        if isinstance(elem, dict):
            if not elem:
                items[prefix] = {}  # Preserve empty dict
            else:
                for k, v in elem.items():
                    new_key = f"{prefix}.{k}" if prefix else k
                    items.update(flatten_element(v, new_key))
        elif isinstance(elem, list):
            if not elem:
                items[prefix] = []  # Preserve empty list
            else:
                for i, v in enumerate(elem):
                    new_key = f"{prefix}.{i}" if prefix else str(i)
                    items.update(flatten_element(v, new_key))
        else:
            items[prefix] = elem
        return items

    df = df.copy()
    for col in df.columns:
        if df[col].dtype == 'object':
            df[col] = df[col].apply(parse_json)

    flat_cols = []
    for col in df.columns:
        if df[col].apply(lambda x: isinstance(x, (dict, list))).any():
            flat_dicts = df[col].apply(lambda x: flatten_element(x, col) if isinstance(x, (dict, list)) else {col: x})
            flat_df = pd.DataFrame(flat_dicts.tolist())
            flat_cols.append(flat_df)
        else:
            flat_cols.append(df[[col]])

    return pd.concat(flat_cols, axis=1)




import pandas as pd

def summarize_dataframe_columns_top_samples_merged(df, top_n=20):
    """
    Summarize each column in the DataFrame with:
    - non-null count
    - null count
    - dtype
    - min, max
    - unique count
    - merged top N frequent sample values as a single column

    Parameters:
        df (pd.DataFrame): Input DataFrame
        top_n (int): Number of top values to merge and display per column

    Returns:
        pd.DataFrame: Summary DataFrame with one row per column
    """
    summary = []

    for col in df.columns:
        col_data = df[col]
        non_null_count = col_data.notnull().sum()
        null_count = col_data.isnull().sum()
        dtype = str(col_data.dtype)

        try:
            min_val = col_data.min()
        except Exception:
            min_val = None
        try:
            max_val = col_data.max()
        except Exception:
            max_val = None

        n_unique = col_data.nunique(dropna=True)

        # Get top N sample values, dropna=False to include NaN if frequent
        top_values = col_data.value_counts(dropna=False).head(top_n).index.tolist()

        # Convert values to string, handle NaN explicitly
        top_values_str = [str(v) if pd.notna(v) else 'NaN' for v in top_values]
        top_values_merged = ", ".join(top_values_str)

        row = {
            "column": col,
            "non_null_count": non_null_count,
            "null_count": null_count,
            "dtype": dtype,
            "min": min_val,
            "max": max_val,
            "n_unique": n_unique,
            "top_samples": top_values_merged
        }

        summary.append(row)

    return pd.DataFrame(summary)











