import pandas as pd
import json

def flatten_nested_columns(df):
    """
    Flattens only the nested (dict/list) columns of a DataFrame,
    first processing native Python structures, then attempting to parse JSON strings.
    Only nested fields are flattened, and new column names are prefixed with the original column name.

    Args:
        df (pd.DataFrame): Input DataFrame

    Returns:
        pd.DataFrame: Flattened DataFrame
    """

    def flatten_element(elem, prefix=''):
        """
        Recursively flattens a nested structure (dict/list) into a flat dictionary.
        Keys are dot-separated paths.
        """
        items = {}
        if isinstance(elem, dict):
            for k, v in elem.items():
                new_key = f"{prefix}.{k}" if prefix else k
                items.update(flatten_element(v, new_key))
        elif isinstance(elem, list):
            for i, v in enumerate(elem):
                new_key = f"{prefix}.{i}" if prefix else str(i)
                items.update(flatten_element(v, new_key))
        else:
            items[prefix] = elem
        return items

    df = df.copy()

    # Step 1: handle actual dict/list objects
    for col in df.columns:
        if df[col].apply(lambda x: isinstance(x, (dict, list))).any():
            flat_dicts = df[col].apply(lambda x: flatten_element(x, col) if isinstance(x, (dict, list)) else {col: x})
            flat_df = pd.DataFrame(flat_dicts.tolist())
            df = df.drop(columns=[col]).join(flat_df)

    # Step 2: handle JSON strings that can be parsed into dict/list
    def try_parse(val):
        if isinstance(val, str):
            try:
                parsed = json.loads(val)
                if isinstance(parsed, (dict, list)):
                    return parsed
            except:
                pass
        return val

    for col in df.columns:
        if df[col].dtype == 'object':
            df[col] = df[col].apply(try_parse)

    for col in df.columns:
        if df[col].apply(lambda x: isinstance(x, (dict, list))).any():
            flat_dicts = df[col].apply(lambda x: flatten_element(x, col) if isinstance(x, (dict, list)) else {col: x})
            flat_df = pd.DataFrame(flat_dicts.tolist())
            df = df.drop(columns=[col]).join(flat_df)

    return df



















import pandas as pd
import json

def flatten_nested_columns(df):
    def flatten_element(elem, prefix=''):
        items = {}
        if isinstance(elem, dict):
            for k, v in elem.items():
                new_key = f"{prefix}.{k}" if prefix else k
                items.update(flatten_element(v, new_key))
        elif isinstance(elem, list):
            for i, v in enumerate(elem):
                new_key = f"{prefix}.{i}" if prefix else str(i)
                items.update(flatten_element(v, new_key))
        else:
            items[prefix] = elem
        return items

    def try_parse(val):
        if isinstance(val, str):
            try:
                parsed = json.loads(val)
                if isinstance(parsed, (dict, list)):
                    return parsed
            except:
                return val
        return val

    df = df.copy()

    # Step 1: Apply json parsing even if it seems unnecessary (forcefully)
    for col in df.columns:
        df[col] = df[col].apply(try_parse)

    # Step 2: Repeat flattening until no nested dict/list remains
    while True:
        # Find columns that still contain dict/list
        nested_cols = [col for col in df.columns if df[col].apply(lambda x: isinstance(x, (dict, list))).any()]
        if not nested_cols:
            break

        for col in nested_cols:
            flattened = df[col].apply(lambda x: flatten_element(x, col) if isinstance(x, (dict, list)) else {col: x})
            flattened_df = pd.DataFrame(flattened.tolist())
            df = df.drop(columns=[col]).join(flattened_df)

    return df
