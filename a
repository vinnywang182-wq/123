import pandas as pd
import json

def flatten_nested_columns(df):
    """
    Flattens only the nested (dict/list) columns of a DataFrame,
    first processing native Python structures, then attempting to parse JSON strings.
    Only nested fields are flattened, and new column names are prefixed with the original column name.

    Args:
        df (pd.DataFrame): Input DataFrame

    Returns:
        pd.DataFrame: Flattened DataFrame
    """

    def flatten_element(elem, prefix=''):
        """
        Recursively flattens a nested structure (dict/list) into a flat dictionary.
        Keys are dot-separated paths.
        """
        items = {}
        if isinstance(elem, dict):
            for k, v in elem.items():
                new_key = f"{prefix}.{k}" if prefix else k
                items.update(flatten_element(v, new_key))
        elif isinstance(elem, list):
            for i, v in enumerate(elem):
                new_key = f"{prefix}.{i}" if prefix else str(i)
                items.update(flatten_element(v, new_key))
        else:
            items[prefix] = elem
        return items

    df = df.copy()

    # Step 1: handle actual dict/list objects
    for col in df.columns:
        if df[col].apply(lambda x: isinstance(x, (dict, list))).any():
            flat_dicts = df[col].apply(lambda x: flatten_element(x, col) if isinstance(x, (dict, list)) else {col: x})
            flat_df = pd.DataFrame(flat_dicts.tolist())
            df = df.drop(columns=[col]).join(flat_df)

    # Step 2: handle JSON strings that can be parsed into dict/list
    def try_parse(val):
        if isinstance(val, str):
            try:
                parsed = json.loads(val)
                if isinstance(parsed, (dict, list)):
                    return parsed
            except:
                pass
        return val

    for col in df.columns:
        if df[col].dtype == 'object':
            df[col] = df[col].apply(try_parse)

    for col in df.columns:
        if df[col].apply(lambda x: isinstance(x, (dict, list))).any():
            flat_dicts = df[col].apply(lambda x: flatten_element(x, col) if isinstance(x, (dict, list)) else {col: x})
            flat_df = pd.DataFrame(flat_dicts.tolist())
            df = df.drop(columns=[col]).join(flat_df)

    return df























import pandas as pd
import json
import numpy as np

def flatten_dict(d, parent_key='', sep='.'):
    """递归展开嵌套字典或列表"""
    items = {}
    if isinstance(d, dict):
        if not d:
            items[parent_key] = {}
        else:
            for k, v in d.items():
                new_key = f"{parent_key}{sep}{k}" if parent_key else k
                items.update(flatten_dict(v, new_key, sep=sep))
    elif isinstance(d, list):
        if not d:
            items[parent_key] = []
        else:
            for i, v in enumerate(d):
                new_key = f"{parent_key}{sep}{i}" if parent_key else str(i)
                items.update(flatten_dict(v, new_key, sep=sep))
    else:
        items[parent_key] = d
    return items

def try_parse_json(val):
    if isinstance(val, str):
        try:
            parsed = json.loads(val)
            if isinstance(parsed, (dict, list)):
                return parsed
        except Exception:
            return val
    return val

def flatten_row(row):
    """一次性处理整行，返回平铺后的字典"""
    flat = {}
    for col, val in row.items():
        parsed_val = try_parse_json(val)
        if isinstance(parsed_val, (dict, list)):
            nested = flatten_dict(parsed_val, col)
            flat.update(nested)
        else:
            flat[col] = parsed_val
    return flat

def flatten_dataframe(df):
    """高性能扁平化函数"""
    flat_data = df.apply(flatten_row, axis=1, result_type='expand')
    # 替换空结构为 NaN（可选）
    flat_data = flat_data.replace({(): np.nan, []: np.nan, {}: np.nan})
    return flat_data
